[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "randseq",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure randseq package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to randseq\n$ nbdev_prepare",
    "crumbs": [
      "randseq"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "randseq",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure randseq package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to randseq\n$ nbdev_prepare",
    "crumbs": [
      "randseq"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "randseq",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/dbikard/randseq.git\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "randseq"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "randseq",
    "section": "How to use",
    "text": "How to use\ntodo",
    "crumbs": [
      "randseq"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\ncalculate_log2fc\n\n calculate_log2fc (df, reference_column='MFDpir', count_threshold=20,\n                   pseudocount=1)\n\n*Filters a DataFrame, normalizes columns by sum, calculates log2 fold change relative to a reference column, and drops the reference column.\nArgs: df (pd.DataFrame): Input DataFrame (rows=features, columns=samples). reference_column (str): Name of the reference sample column. count_threshold (int): Minimum count in reference column to keep a feature. pseudocount (float): Value added to normalized counts before log2FC.\nReturns: pd.DataFrame: DataFrame with log2 fold change values. None if reference column is missing. Empty DataFrame if all rows are filtered out.*\n\ncounts_file=\"countsTable.csv\"\nfile_path=os.path.join(data_path,counts_file)\ncounts=pd.read_csv(file_path, index_col=0)\ncounts = counts[[col for col in counts.columns if (\"_T0\" in col) or (\"MFDpir\" in col)]]\n\nlog2fc_df = calculate_log2fc(counts, reference_column='MFDpir', count_threshold=20, pseudocount=1)\nlog2fc_df.min(axis=0)\n\nK12_T0       -2.844874\nHS_T0        -3.320280\nE1114_T0     -4.544421\nE1167_T0     -3.645600\nH120_T0      -3.572726\nTA054_T0     -3.319211\nTA447_T0     -3.566876\nE101_T0      -8.108167\n41-1Ti9_T0   -4.255918\nTA280_T0     -4.800802\nM114_T0      -4.143357\nTA249_T0     -4.973009\nROAR8_T0     -4.621302\nJJ1886_T0    -9.188692\nCFT073_T0    -3.868714\nAPECO1_T0    -6.525634\nUTI89_T0     -8.571068\nS88_T0       -8.601767\nMG1655_T0    -4.777041\ndtype: float64\n\n\n\nsource\n\n\nrevcomp\n\n revcomp (seq:str)\n\nComputes the reverse complement of a sequence\n\nassert revcomp(\"ATGC\")==\"GCAT\"\nassert revcomp(\"ATGCN\")==\"NGCAT\"\nassert revcomp(\"atgNN\")==\"NNCAT\"\n\n\nsource\n\n\nallseqs\n\n allseqs (n, seqs=[''])\n\nRecursive function that generates all possible sequences of length n seqs is a list of sequences to which we will add bases\n\n\",\".join(allseqs(2))\n\n'AA,AT,AG,AC,TA,TT,TG,TC,GA,GT,GG,GC,CA,CT,CG,CC'\n\n\n\nassert flatten([[1,2],[3,4],[5,6]])==[1, 2, 3, 4, 5, 6]\n\n\nsource\n\n\nget_all_sites\n\n get_all_sites (pattern)\n\n\nget_all_sites((3,6,4))[:5]\n\n['AAANNNNNNAAAA',\n 'AAANNNNNNAAAT',\n 'AAANNNNNNAAAG',\n 'AAANNNNNNAAAC',\n 'AAANNNNNNAATA']",
    "crumbs": [
      "Utils"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "1. Computing the log2fc of the sequences from counts data\n\ncounts_file=\"countsTable.csv\"\nfile_path=os.path.join(data_path,counts_file)\ncounts=pd.read_csv(file_path, index_col=0)\ncounts = counts[[col for col in counts.columns if (\"_T0\" in col) or (\"MFDpir\" in col)]]\n\nlog2fc_df = calculate_log2fc(counts, reference_column='MFDpir', count_threshold=20, pseudocount=1)\nlog2fc_df\n\n\n\n\n\n\n\n\nK12_T0\nHS_T0\nE1114_T0\nE1167_T0\nH120_T0\nTA054_T0\nTA447_T0\nE101_T0\n41-1Ti9_T0\nTA280_T0\nM114_T0\nTA249_T0\nROAR8_T0\nJJ1886_T0\nCFT073_T0\nAPECO1_T0\nUTI89_T0\nS88_T0\nMG1655_T0\n\n\n\n\nCGGAGGTACTGGGTACATTT\n0.043818\n0.049551\n0.187868\n-0.302314\n0.238304\n0.051836\n0.186450\n0.093344\n0.029484\n0.106924\n-0.329062\n-0.102645\n0.144280\n0.084854\n0.212674\n0.229591\n-0.457070\n0.213624\n0.090458\n\n\nTGGCGATAATGCCGGCTATC\n0.045463\n0.137127\n0.437387\n0.113014\n0.137767\n0.060845\n0.063668\n-0.014449\n-0.008977\n-0.025606\n0.003605\n0.084441\n-0.167417\n0.018354\n0.041919\n0.016410\n-0.207488\n0.092292\n0.101627\n\n\nTTCCAGTTCACTGGTCTTCG\n-0.049694\n0.049903\n-0.105148\n-0.061620\n-0.081886\n-0.072083\n0.402207\n0.087885\n0.207649\n0.127306\n0.204781\n-0.106153\n-0.012804\n0.285761\n-0.167107\n0.269887\n0.182096\n0.458076\n0.128330\n\n\nAATTTCAGTGCCGTTCAGAT\n-0.251957\n-0.422224\n-0.224591\n-0.058728\n-0.204575\n-0.192908\n-0.220676\n-0.143054\n-0.277042\n-0.205084\n0.058866\n-0.064442\n-0.029019\n-0.042375\n-0.095307\n-0.254714\n0.460256\n-0.183890\n-0.180938\n\n\nCTGCGGTAATAATTCCCGCC\n-0.178427\n-0.154025\n0.581087\n0.401967\n0.047002\n-0.309751\n-0.200689\n-0.292042\n-0.473919\n-0.298991\n-0.221896\n-0.060500\n0.085888\n-0.279165\n-0.206676\n-0.097563\n-0.347949\n-0.188758\n-0.186226\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\nGCTTGATGTAGCCTTCGAAC\n-0.100518\n-0.079966\n0.027302\n-0.268222\n-0.337706\n-0.047079\n-0.072379\n-0.246364\n-0.250380\n-0.142468\n-0.091826\n-0.004635\n0.260965\n-0.174715\n0.278843\n-0.206298\n-0.319604\n-0.055837\n-0.133185\n\n\nTAATGGCAAATTGACACTCC\n0.258205\n0.103683\n0.428049\n-0.106268\n0.247864\n0.050536\n0.240706\n0.133009\n0.195027\n0.096144\n0.482377\n-0.168566\n-0.008969\n0.224936\n0.009979\n0.217354\n0.453491\n0.201961\n0.387054\n\n\nGCTGCGCGCGGAGTTGTTCC\n-0.629856\n-0.381054\n-0.431536\n-0.328063\n-0.461695\n-0.258496\n-0.442414\n-0.358037\n-0.372732\n-0.359784\n-0.581490\n0.174623\n-0.984388\n-0.273490\n-0.490203\n-0.122278\n-0.562652\n-0.497605\n-0.959646\n\n\nGCAACACGCCAGTAAGGTGT\n0.693416\n0.487153\n0.744586\n-0.054785\n0.474863\n0.585146\n0.162493\n0.388078\n0.733043\n0.280496\n0.167936\n0.605561\n0.400524\n0.051808\n0.422091\n0.098976\n0.294288\n0.064457\n0.376418\n\n\nGATAGCCGGATAGCTTAAGG\n-0.245685\n-0.131631\n-0.429244\n-0.213968\n-0.271218\n-0.171113\n-0.015624\n-0.355447\n-0.236553\n-0.093049\n-0.299090\n-0.282985\n-0.134136\n-0.079377\n-0.211507\n-0.151722\n-0.154721\n-0.400835\n0.140210\n\n\n\n\n11503 rows × 19 columns\n\n\n\n\n\n2. Obtaining the sequence context of the variable sequence to identify sites at the boundaries of the variable sequence\n\nsource\n\n\nget_lib_seq_context\n\n get_lib_seq_context (seqs, left, right)\n\n*Generates a list of sequences by combining a left and right sequence with each sequence in the input list.\nArgs: seqs (list): List of sequences to be combined. left (str): Left sequence to prepend. right (str): Right sequence to append.\nReturns: list: List of combined sequences.*\n\nleft, right = \"GTCCTAGGTATAATACTAGT\", \"GTTTTAGAGCTAGAAATAGC\"\nlib=get_lib_seq_context(log2fc_df.index,left,right)\nlib[:5]\n\n['GTCCTAGGTATAATACTAGTCGGAGGTACTGGGTACATTTGTTTTAGAGCTAGAAATAGC',\n 'GTCCTAGGTATAATACTAGTTGGCGATAATGCCGGCTATCGTTTTAGAGCTAGAAATAGC',\n 'GTCCTAGGTATAATACTAGTTTCCAGTTCACTGGTCTTCGGTTTTAGAGCTAGAAATAGC',\n 'GTCCTAGGTATAATACTAGTAATTTCAGTGCCGTTCAGATGTTTTAGAGCTAGAAATAGC',\n 'GTCCTAGGTATAATACTAGTCTGCGGTAATAATTCCCGCCGTTTTAGAGCTAGAAATAGC']\n\n\n\n\n3. Listing all the sequence motifs found in our library that follow a specific pattern\nThe pattern is a list of 3 numbers: 1. The number of defined bases in the first part of the site\n2. The number of undefined bases in the middle\n3. The number of defined bases in the second part of the site\n\nsource\n\n\nget_sites_in_seq\n\n get_sites_in_seq (lib, pattern=(3, 6, 4), no_ori=True)\n\nComputes the list of unique sites matching the pattern present in each sequence of the library The pattern is a list of 3 number: 1. The number of defined bases in the first part of the site 2. The number of undefined bases in the middle 3. The number of defined bases in the second part of the site\n\nlib=get_lib_seq_context(log2fc_df.index,left,right)\nsites_in_seq=get_sites_in_seq(lib,pattern=(3,6,4),no_ori=True)\nassert len(sites_in_seq) == len(lib)\nprint(f\"First 5 pattern matching sequences found in the first sequence of the library:\")\nlist(sites_in_seq[0])[:5]\n\nFirst 5 pattern matching sequences found in the first sequence of the library:\n\n\n['AGCNNNNNNTAGC',\n 'CTGNNNNNNTTTG',\n 'TAGNNNNNNAAAT',\n 'ACTNNNNNNATTT',\n 'ACANNNNNNCCCA']\n\n\n\nsource\n\n\nscore\n\n score (FCs, thr=-1)\n\nReturns the fraction of sequences depleted below the thr value. Handles empty lists of FCs by returning 0.\n\nassert score([-2,-0.5,-0.1,-5],thr=-1) == 0.5\n\n\nsource\n\n\nidentify_depleted_motifs_scanning_ends\n\n identify_depleted_motifs_scanning_ends (log2fc_series, scan_depth_k=6,\n                                         max_motif_length=6,\n                                         depletion_threshold=-1,\n                                         score_thr=0.85,\n                                         min_sequence_support=5)\n\n*Identifies DNA motifs associated with sequence depletion by scanning k positions from both the left and right ends of sequences, using a pandas Series of log2FC values.\nArgs: log2fc_series (pd.Series): pandas Series with sequences (DNA strings) as index and log2FC values as data. scan_depth_k (int): The number of positions to scan from each end (0 to k inclusive). max_motif_length (int): The maximum length of the motif to consider. depletion_threshold (float): The log2FC threshold for considering a sequence depleted. min_sequence_support (int): The minimum number of sequences (strictly greater than this value) a motif must be found in to be included in the results.\nReturns: pd.DataFrame: A DataFrame with identified motifs, their length, actual 0-indexed position, number of occurrences, average log2FC, and depletion score (fraction_depleted). Sorted by primary depletion metrics.*\n\ndepleted_motifs_df=identify_depleted_motifs_scanning_ends(log2fc_df[\"JJ1886_T0\"])\ndepleted_motifs_df.head(10)\n\nAnalyzing motifs of length 1 to 6, scanning positions 0 to 6 from each end, for JJ1886_T0.\nMinimum sequence support for a motif: &gt; 5 (i.e., 6 or more)\n\n\n\n\n\n\n\n\n\nmotif\nlength\nposition\nnum_sequences\navg_log2fc\nfraction_depleted\n\n\n\n\n8695\nAAAAG\n5\n11\n10\n-5.662158\n1.0\n\n\n22013\nGTGCGG\n6\n0\n6\n-5.490821\n1.0\n\n\n12567\nAAAGT\n5\n12\n13\n-5.262390\n1.0\n\n\n12568\nCAAAG\n5\n11\n16\n-5.201596\n1.0\n\n\n17472\nGTGCG\n5\n0\n10\n-5.107176\n1.0\n\n\n2571\nAAAG\n4\n12\n42\n-5.076919\n1.0\n\n\n2580\nAAAGC\n5\n12\n9\n-5.029139\n1.0\n\n\n17128\nAAAGA\n5\n12\n13\n-4.996286\n1.0\n\n\n10197\nGTGTC\n5\n0\n6\n-4.959089\n1.0\n\n\n23364\nAAAGG\n5\n12\n7\n-4.943650\n1.0\n\n\n\n\n\n\n\n\nsource\n\n\nfilter_to_core_motifs\n\n filter_to_core_motifs (depleted_motifs_df, score_improvement_margin=0.05)\n\n*Filters a DataFrame of depleted motifs to identify underlying “core” motifs. A longer motif is kept only if it’s significantly better than a shorter core motif it contains.\nArgs: depleted_motifs_df (pd.DataFrame): DataFrame from identify_depleted_motifs_scanning_ends. score_improvement_margin (float): A longer motif’s ‘fraction_depleted’ must be greater than the core motif’s score by this margin. fc_improvement_margin (float): A longer motif’s ‘avg_log2fc’ must be lower than the core motif’s avg_log2fc by this margin.\nReturns: pd.DataFrame: A filtered DataFrame containing potentially core motifs.*\n\ndepleted_motifs_df=filter_to_core_motifs(depleted_motifs_df)\ndepleted_motifs_df.head(10)\n\n\n\n\n\n\n\n\nmotif\nlength\nposition\nnum_sequences\navg_log2fc\nfraction_depleted\n\n\n\n\n0\nGTG\n3\n0\n187\n-4.764500\n1.0\n\n\n1\nAAAG\n4\n12\n42\n-5.076919\n1.0\n\n\n\n\n\n\n\n\nsource\n\n\nget_fold_change_values_per_site\n\n get_fold_change_values_per_site (site_sets_list, fold_changes_list)\n\n*Computes a dictionary mapping each unique site to a list of its associated log2 Fold Change (FC) values.\nArgs: site_sets_list (list): A list of sets, where each set contains the sequence motifs found in a member of the library. fold_changes_list (list): A list of log2FC values, corresponding to each sequence in the library.\nReturns: dict: A dictionary where keys are sequence motifs and values are numpy arrays containing the log2FC values associated with that site.*\n\npattern=(3,6,4)\nset_list=get_sites_in_seq(lib,pattern=pattern,no_ori=True)\nsite_FCs=get_fold_change_values_per_site(set_list,log2fc_df[\"JJ1886_T0\"].values)\nsite_FCs[\"AGCNNNNNNGGGA\"]\n\narray([ 0.02025893, -0.15083807,  0.19052559,  0.04266223,  0.22493562,\n       -0.13188093,  0.0203179 ,  0.10373391, -0.18265707,  0.24137364,\n       -0.10160173,  0.5539999 ,  0.19568499,  0.29179059, -0.02109236,\n       -0.46896125,  0.00812423])\n\n\n\nsource\n\n\nfilter_sequences_without_core_motifs\n\n filter_sequences_without_core_motifs (log2fc_series, core_motifs_df)\n\n*Filters an original log2fc Series to remove sequences that contain any of the specified core motifs.\nArgs: log2fc_series (pd.Series): Series with sequences as its index and log2FC values. core_motifs_df (pd.DataFrame): DataFrame of core motifs, must include ‘motif’, ‘position’, and ‘length’ columns.\nReturns: pd.Series: A new Series containing only sequences (and their log2FC values) from log2fc_series that do not carry any of the core motifs.*\n\nfilted_log2fc_df = filter_sequences_without_core_motifs(log2fc_df, depleted_motifs_df)\n\n\nsource\n\n\nget_sites_scores\n\n get_sites_scores (site_FCs, pattern, log2FC_thr=-1)\n\nScores sites based on depletion and occurrence. Returns a pandas DataFrame with ‘site’, ‘fraction_depleted’, ‘num_sequences’, ‘avg_log2fc’.\n\nsite_scores = get_sites_scores(site_FCs,pattern)\nsite_scores.sort_values(by=['fraction_depleted', 'num_sequences'], ascending=[False, False]).head(10)\n\n\n\n\n\n\n\n\nmotif\nfraction_depleted\nnum_sequences\navg_log2fc\n\n\n\n\n2652\nAGGNNNNNNCCTC\n1.000000\n1\n-4.601867\n\n\n8786\nGAGNNNNNNCCCC\n1.000000\n1\n-1.406262\n\n\n4410\nCACNNNNNNATTA\n0.958974\n195\n-4.569183\n\n\n952\nAATNNNNNNGTGC\n0.826923\n52\n-3.962960\n\n\n953\nAATNNNNNNGTGG\n0.815385\n65\n-3.883041\n\n\n12519\nTAANNNNNNTGTG\n0.785714\n238\n-3.746732\n\n\n951\nAATNNNNNNGTGA\n0.771429\n70\n-3.628320\n\n\n8882\nGAGNNNNNNGTCT\n0.750000\n4\n-4.012801\n\n\n954\nAATNNNNNNGTGT\n0.740741\n54\n-3.485249\n\n\n11042\nGGTNNNNNNAGGA\n0.666667\n3\n-2.235343\n\n\n\n\n\n\n\n\nsource\n\n\nfilter_to_core_flexible_motifs\n\n filter_to_core_flexible_motifs (flexible_motifs_df, score_margin=0.05)\n\n*Filters a DataFrame of flexible (position-independent) motifs to identify underlying “core” motifs. A longer/more complex motif is removed if its score is not significantly better than a simpler core motif pattern it contains.\nArgs: flexible_motifs_df (pd.DataFrame): DataFrame with ‘site’, ‘pattern’ (string like ‘(3,4,4)’), ‘fraction_depleted’, ‘num_sequences’, ‘avg_log2fc’. score_margin (float): A more complex motif is subsumed if its ‘fraction_depleted’ is not better than (core_score - score_margin). Effectively, if candidate_score &gt;= core_score - score_margin, it’s subsumed.\nReturns: pd.DataFrame: A filtered DataFrame containing potentially core flexible motifs.*\n\ndef analyze_motif_pipeline(log2fc_series, \n                           left_context_str, \n                           right_context_str, \n                           fixed_motif_scan_depth_k=0,\n                           fixed_motif_max_length=6,\n                           fixed_motif_depletion_thr=-1,\n                           fixed_motif_score_thr=0.8,\n                           fixed_motif_min_support=5,\n                           core_motif_score_margin=0.05, # For fixed motifs\n                           flexible_motif_patterns=[(6,0,0),(3,4,4)], \n                           flexible_motif_log2fc_thr=-1,\n                           flexible_motif_min_support=5,\n                           flexible_motif_score_thr=0.8,\n                           core_flexible_motif_score_margin=0.05 # For flexible motifs\n                           ):\n    \"\"\"\n    Full pipeline to identify fixed-position core motifs and then position-independent motifs\n    (from a list of patterns) in the remaining sequences (with context for flexible search).\n    \"\"\"\n    print(\"--- Starting Fixed-Position Motif Analysis (on original short sequences) ---\")\n    depleted_fixed_motifs_df = identify_depleted_motifs_scanning_ends(\n        log2fc_series, \n        scan_depth_k=fixed_motif_scan_depth_k,\n        max_motif_length=fixed_motif_max_length,\n        depletion_threshold=fixed_motif_depletion_thr,\n        score_thr=fixed_motif_score_thr,\n        min_sequence_support=fixed_motif_min_support\n    )\n    core_fixed_motifs_df = filter_to_core_motifs( \n        depleted_fixed_motifs_df,\n        score_improvement_margin=core_motif_score_margin\n    )\n    if core_fixed_motifs_df.empty:\n        print(\"No core motifs found at fixed positions.\")\n    else:\n        print(f\"Found {len(core_fixed_motifs_df)} core motifs at fixed positions:\")\n        for _, row in core_fixed_motifs_df.iterrows():\n            print(f\"  - Fixed Motif: {row['motif']}, Pos: {row['position']}, Len: {row['length']}, FracDep: {row['fraction_depleted']:.2f}, AvgFC: {row['avg_log2fc']:.2f}, N: {row['num_sequences']}\")\n\n    print(\"\\n--- Starting Position-Independent Motif Analysis on Filtered Sequences (with context) ---\")\n    log2fc_series_for_flexible_analysis = filter_sequences_without_core_motifs(\n        log2fc_series, \n        core_fixed_motifs_df \n    )\n    if len(log2fc_series_for_flexible_analysis) == len(log2fc_series):\n        print(\"No sequences were filtered out based on fixed-position core motifs (or no core motifs found).\")\n    else:\n        print(f\"Filtered log2fc_series for flexible analysis: {len(log2fc_series_for_flexible_analysis)} sequences remaining.\")\n\n    if log2fc_series_for_flexible_analysis.empty:\n        print(\"No sequences remaining for flexible motif analysis after filtering.\")\n        flexible_motifs_results_df = pd.DataFrame(columns=['motif', 'pattern', 'fraction_depleted', 'num_sequences', 'avg_log2fc']) \n        return core_fixed_motifs_df, flexible_motifs_results_df\n\n    short_sequences_for_flex_analysis = log2fc_series_for_flexible_analysis.index.tolist()\n    sequences_with_context_for_flex = get_lib_seq_context(\n        short_sequences_for_flex_analysis, \n        left_context_str, \n        right_context_str\n    )\n    fc_values_for_flexible_analysis = log2fc_series_for_flexible_analysis.tolist()\n    \n    all_flexible_motifs_data_list = [] \n\n    if not isinstance(flexible_motif_patterns, list):\n        print(\"Warning: flexible_motif_patterns should be a list. Wrapping it in a list.\")\n        flexible_motif_patterns = [flexible_motif_patterns]\n    \n    for current_flex_pattern in flexible_motif_patterns:\n        # print(f\"  Pattern: {current_flex_pattern}\") # Reduced verbosity\n        site_sets_flexible = get_sites_in_seq(\n            sequences_with_context_for_flex, \n            pattern=current_flex_pattern, \n            no_ori=True \n        )\n        if len(site_sets_flexible) != len(fc_values_for_flexible_analysis):\n            print(f\"    Error: Mismatch in length between site sets ({len(site_sets_flexible)}) and FC values ({len(fc_values_for_flexible_analysis)}) for pattern {current_flex_pattern}. Skipping this pattern.\")\n            continue\n\n        site_fcs_flexible = get_fold_change_values_per_site(\n            site_sets_flexible,\n            fc_values_for_flexible_analysis \n        )\n        current_pattern_scores_df = get_sites_scores( \n            site_fcs_flexible,\n            pattern=current_flex_pattern, \n            log2FC_thr=flexible_motif_log2fc_thr\n        )\n        \n        if not current_pattern_scores_df.empty:\n            current_pattern_scores_df.rename(columns={'site': 'motif'}, inplace=True) \n            current_pattern_scores_df['pattern'] = str(current_flex_pattern) \n            filtered_for_this_pattern = current_pattern_scores_df[\n                (current_pattern_scores_df['fraction_depleted'] &gt; flexible_motif_score_thr) &\n                (current_pattern_scores_df['num_sequences'] &gt; flexible_motif_min_support)\n            ]\n            if not filtered_for_this_pattern.empty:\n                all_flexible_motifs_data_list.append(filtered_for_this_pattern)\n\n    if not all_flexible_motifs_data_list:\n        print(f\"\\nNo flexible motifs found meeting initial support &gt; {flexible_motif_min_support} and score &gt; {flexible_motif_score_thr} for any provided pattern.\")\n        flexible_motifs_results_df = pd.DataFrame(columns=['motif', 'pattern', 'fraction_depleted', 'num_sequences', 'avg_log2fc']) \n    else:\n        combined_flexible_motifs_df = pd.concat(all_flexible_motifs_data_list, ignore_index=True)\n        print(f\"\\nIdentified {len(combined_flexible_motifs_df)} raw flexible motifs. Now filtering to core flexible motifs...\")\n        \n        flexible_motifs_results_df = filter_to_core_flexible_motifs( \n            combined_flexible_motifs_df,\n            score_margin=core_flexible_motif_score_margin \n        )\n        if flexible_motifs_results_df.empty:\n            print(\"No core flexible motifs remained after filtering.\")\n        else:\n            print(f\"Found {len(flexible_motifs_results_df)} core flexible motifs:\")\n            for _, row in flexible_motifs_results_df.iterrows():\n                 print(f\"  - Flex Motif: {row['motif']} (from pattern {row['pattern']}), FracDep: {row['fraction_depleted']:.2f}, AvgFC: {row['avg_log2fc']:.2f}, N: {row['num_sequences']}\")\n        \n    return core_fixed_motifs_df, flexible_motifs_results_df\n\n\ncore_fixed_motifs_df, flexible_motifs_df = analyze_motif_pipeline(log2fc_df[\"JJ1886_T0\"], \n                        left,\n                        right, \n                        fixed_motif_scan_depth_k=6,\n                        fixed_motif_max_length=5,\n                        fixed_motif_depletion_thr=-1,\n                        fixed_motif_score_thr=0.85,\n                        fixed_motif_min_support=5,\n                        core_motif_score_margin=0.05,\n                        flexible_motif_patterns=[(6,0,0),(4,4,4),(3,4,4),(2,4,3),(3,5,4)],\n                        flexible_motif_log2fc_thr=-1,\n                        flexible_motif_min_support=3,\n                        flexible_motif_score_thr=0.85\n                        )\n\n--- Starting Fixed-Position Motif Analysis (on original short sequences) ---\nAnalyzing motifs of length 1 to 5, scanning positions 0 to 6 from each end, for JJ1886_T0.\nMinimum sequence support for a motif: &gt; 5 (i.e., 6 or more)\nFound 2 core motifs at fixed positions:\n  - Fixed Motif: GTG, Pos: 0, Len: 3, FracDep: 1.00, AvgFC: -4.76, N: 187\n  - Fixed Motif: AAAG, Pos: 12, Len: 4, FracDep: 1.00, AvgFC: -5.08, N: 42\n\n--- Starting Position-Independent Motif Analysis on Filtered Sequences (with context) ---\nFiltered log2fc_series for flexible analysis: 11275 sequences remaining.\n\nIdentified 21 raw flexible motifs. Now filtering to core flexible motifs...\nFound 5 core flexible motifs:\n  - Flex Motif: GAGACC (from pattern (6, 0, 0)), FracDep: 1.00, AvgFC: -4.31, N: 9\n  - Flex Motif: AACNNNNCTTT (from pattern (3, 4, 4)), FracDep: 1.00, AvgFC: -5.33, N: 21\n  - Flex Motif: CACNNNNGTAC (from pattern (3, 4, 4)), FracDep: 1.00, AvgFC: -5.24, N: 20\n  - Flex Motif: CACNNNNGTAT (from pattern (3, 4, 4)), FracDep: 1.00, AvgFC: -4.43, N: 5\n  - Flex Motif: GACCNNNNCCTC (from pattern (4, 4, 4)), FracDep: 1.00, AvgFC: -4.36, N: 4\n\n\n\ncore_fixed_motifs_df\n\n\n\n\n\n\n\n\nmotif\nlength\nposition\nnum_sequences\navg_log2fc\nfraction_depleted\n\n\n\n\n0\nGTG\n3\n0\n187\n-4.764500\n1.0\n\n\n1\nAAAG\n4\n12\n42\n-5.076919\n1.0\n\n\n\n\n\n\n\n\nflexible_motifs_df\n\n\n\n\n\n\n\n\nmotif\nfraction_depleted\nnum_sequences\navg_log2fc\npattern\n\n\n\n\n0\nGAGACC\n1.0\n9\n-4.313837\n(6, 0, 0)\n\n\n1\nAACNNNNCTTT\n1.0\n21\n-5.325198\n(3, 4, 4)\n\n\n2\nCACNNNNGTAC\n1.0\n20\n-5.237623\n(3, 4, 4)\n\n\n3\nCACNNNNGTAT\n1.0\n5\n-4.428066\n(3, 4, 4)\n\n\n4\nGACCNNNNCCTC\n1.0\n4\n-4.357958\n(4, 4, 4)\n\n\n\n\n\n\n\n\ndef get_flexible_motif_presence_in_library(short_sequences_list, left_context, right_context, flexible_motifs_df):\n    \"\"\"\n    Creates a DataFrame indicating the presence of flexible motifs in sequences (with context).\n\n    Args:\n        short_sequences_list (list): List of original short DNA sequences.\n        left_context (str): Left context string to prepend.\n        right_context (str): Right context string to append.\n        flexible_motifs_df (pd.DataFrame): DataFrame of flexible motifs, must include\n                                           a 'motif' column with motif strings (e.g., 'AACNNNNCTTT').\n\n    Returns:\n        pd.DataFrame: DataFrame with full sequences (with context) as index,\n                      flexible motif strings as columns, and boolean values indicating presence.\n    \"\"\"\n    if not isinstance(short_sequences_list, list):\n        print(\"Error: short_sequences_list must be a list.\")\n        return pd.DataFrame()\n    if not isinstance(flexible_motifs_df, pd.DataFrame) or 'motif' not in flexible_motifs_df.columns:\n        print(\"Error: flexible_motifs_df is invalid or missing 'motif' column.\")\n        return pd.DataFrame()\n\n    full_sequences_with_context = get_lib_seq_context(short_sequences_list, left_context, right_context)\n    \n    # Filter out None entries from full_sequences_with_context which may arise from non-string inputs to get_lib_seq_context\n    # and keep track of original indices to align with short_sequences_list if needed for other purposes,\n    # though for this function, we just use the valid full sequences.\n    valid_full_sequences = [seq for seq in full_sequences_with_context if isinstance(seq, str)]\n    if not valid_full_sequences:\n        print(\"No valid full sequences to process after adding context.\")\n        return pd.DataFrame()\n\n    unique_flexible_motifs = flexible_motifs_df['motif'].unique()\n    \n    presence_data = []\n\n    for full_seq_str in valid_full_sequences:\n        row_data = {'full_sequence': full_seq_str}\n        for flex_motif_str in unique_flexible_motifs:\n            if not isinstance(flex_motif_str, str) or not flex_motif_str:\n                row_data[flex_motif_str] = False # Or handle as error/skip\n                continue\n            \n            # Convert 'N' to '[ATGC]' for regex matching\n            regex_pattern = flex_motif_str.replace('N', '[ATGC]')\n            try:\n                if re.search(regex_pattern, full_seq_str):\n                    row_data[flex_motif_str] = True\n                elif re.search(regex_pattern, revcomp(full_seq_str)):\n                    row_data[flex_motif_str] = True\n                else:\n                    row_data[flex_motif_str] = False\n            except re.error:\n                # print(f\"Warning: Regex error for motif '{flex_motif_str}' (pattern: '{regex_pattern}'). Marking as False.\")\n                row_data[flex_motif_str] = False\n        presence_data.append(row_data)\n\n    if not presence_data:\n        return pd.DataFrame(index=valid_full_sequences, columns=unique_flexible_motifs)\n\n    presence_df = pd.DataFrame(presence_data)\n    if 'full_sequence' in presence_df.columns:\n        presence_df = presence_df.set_index('full_sequence')\n        \n    return presence_df\n\n\nmotif_presence_df = get_flexible_motif_presence_in_library(\n            short_sequences_list=counts.index.tolist(),\n            left_context=left.upper(),\n            right_context=right.upper(),\n            flexible_motifs_df=flexible_motifs_df # Use the output from the pipeline\n        )\n\nmotif_presence_df.loc[motif_presence_df[\"GACCNNNNCCTC\"]]\n\n\n\n\n\n\n\n\nGAGACC\nAACNNNNCTTT\nCACNNNNGTAC\nCACNNNNGTAT\nGACCNNNNCCTC\n\n\nfull_sequence\n\n\n\n\n\n\n\n\n\nGTCCTAGGTATAATACTAGTGAGGTTCAGGTCATGACCAAGTTTTAGAGCTAGAAATAGC\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\nGTCCTAGGTATAATACTAGTCCTGAGACCTCTGCCTCCGGGTTTTAGAGCTAGAAATAGC\nTrue\nFalse\nFalse\nFalse\nTrue\n\n\nGTCCTAGGTATAATACTAGTCTGAGACCTCTGCCTCCGGAGTTTTAGAGCTAGAAATAGC\nTrue\nFalse\nFalse\nFalse\nTrue\n\n\nGTCCTAGGTATAATACTAGTGAACCTGAGACCTCTGCCTCGTTTTAGAGCTAGAAATAGC\nTrue\nFalse\nFalse\nFalse\nTrue\n\n\n\n\n\n\n\n\nfor motif in motif_presence_df.columns:\n    df = motif_presence_df.loc[motif_presence_df[motif]].copy()\n    df = df.drop(columns=[motif])\n    other_site_found = df.any(axis=1)\n    freq_of_other_site_found = np.sum(other_site_found) / len(other_site_found)\n    print(motif, freq_of_other_site_found)\n\nGAGACC 0.3333333333333333\nAACNNNNCTTT 0.031746031746031744\nCACNNNNGTAC 0.05\nCACNNNNGTAT 0.005208333333333333\nGACCNNNNCCTC 0.75\n\n\n\nsource\n\n\nplot_flexible_motif_analysis\n\n plot_flexible_motif_analysis (counts_df, sample_col, ref_col,\n                               flexible_motifs_df, left_context_str,\n                               right_context_str, title_main='Flexible\n                               Motif Analysis', pseudocount=1)\n\nGenerates two subplots for FLEXIBLE (position-independent) motifs, considering sequence context. Uses get_flexible_motif_presence_in_library to simplify highlighting.\n\nplot_flexible_motif_analysis(counts, \"JJ1886_T0\", \"MFDpir\", flexible_motifs_df, left, right)",
    "crumbs": [
      "core"
    ]
  }
]