"""useful basic functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_utils.ipynb.

# %% auto 0
__all__ = ['bases', 'flatten', 'calculate_log2fc', 'revcomp', 'allseqs', 'get_all_sites']

# %% ../nbs/01_utils.ipynb 3
import pandas as pd
import seaborn as sns
from tqdm import tqdm
import re
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import pearsonr,spearmanr
import os
from collections import Counter, defaultdict
import re
from random import choice
from itertools import groupby, chain
from operator import itemgetter
import os

# %% ../nbs/01_utils.ipynb 5
def calculate_log2fc(df, reference_column='MFDpir', count_threshold=20, pseudocount=1):
    """
    Filters a DataFrame, normalizes columns by sum, calculates log2 fold change
    relative to a reference column, and drops the reference column.

    Args:
        df (pd.DataFrame): Input DataFrame (rows=features, columns=samples).
        reference_column (str): Name of the reference sample column.
        count_threshold (int): Minimum count in reference column to keep a feature.
        pseudocount (float): Value added to normalized counts before log2FC.

    Returns:
        pd.DataFrame: DataFrame with log2 fold change values. None if reference
                      column is missing. Empty DataFrame if all rows are filtered out.
    """
    if reference_column not in df.columns:
        print(f"Error: Reference column '{reference_column}' not found in DataFrame.")
        return None

    # 1. Filter rows
    df_filtered = df[df[reference_column] > count_threshold].copy()
    if df_filtered.empty:
        print("DataFrame is empty after filtering.")
        return pd.DataFrame()

    # 2. Add pseudocount
    # The pseudocount is added here, before normalization.
    df_with_pseudocount = df_filtered + pseudocount

    # 3. Normalize each column by its sum
    # Normalization is now performed on the data that includes the pseudocount.
    # df.sum(axis=0) calculates sum for each column.
    # .div performs element-wise division, axis=1 aligns column_sums with columns.
    column_sums = df_with_pseudocount.sum(axis=0)
    
    # Handle cases where column_sums might be zero (e.g., if all values were -pseudocount after filtering, though unlikely with positive counts)
    # If a column sum is 0 after adding pseudocount, it implies an issue or very specific data.
    # Division by zero will result in NaN or inf.
    df_processed = df_with_pseudocount.div(column_sums, axis=1)

    # Check if reference column still exists (it should)
    if reference_column not in df_processed.columns:
        # This check is crucial as operations might alter columns if not handled carefully.
        print(f"Error: Reference column '{reference_column}' lost during processing.")
        return None
        
    reference_values = df_processed[reference_column]

    # 4. Calculate log2FC
    # .div performs element-wise division, axis=0 aligns reference_values (a Series) with rows of df_processed.
    log2fc_df = np.log2(df_processed.div(reference_values, axis=0))
    
    # Columns are already named correctly from df_processed.

    # 5. Drop the reference column's own log2FC (which will be ~zeros)
    if reference_column in log2fc_df.columns:
        log2fc_df = log2fc_df.drop(columns=[reference_column])
    else:
        print(f"Warning: Reference column '{reference_column}' not found in log2fc_df for dropping.")
        
    return log2fc_df

# %% ../nbs/01_utils.ipynb 8
def revcomp(seq:str):
    '''Computes the reverse complement of a sequence'''
    trns=str.maketrans("ATGCN","TACGN")
    return seq.upper().translate(trns)[::-1]

# %% ../nbs/01_utils.ipynb 10
bases=list("ATGC")
def allseqs(n,seqs=[""]):
    '''Recursive function that generates all possible sequences of length n
    seqs is a list of sequences to which we will add bases
    '''
    seqs=[s+b for s in seqs for b in bases]
    if len(seqs[0])<n:
        return allseqs(n,seqs)
    else:
        return seqs

# %% ../nbs/01_utils.ipynb 12
flatten = lambda l: [item for sublist in l for item in sublist]

# %% ../nbs/01_utils.ipynb 14
def get_all_sites(pattern):
    #generates a list of all sites that match the pattern
    return [s[:pattern[0]]+"N"*pattern[1]+s[pattern[0]:] for s in allseqs(pattern[0]+pattern[2])]

